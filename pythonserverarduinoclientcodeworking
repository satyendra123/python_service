python server code which accepts the ip 192.168.1.151 and port 6000 arduino will connect with this ip and port only to the python server
DbPath=server=127.0.0.1;user=root;password=;database=paytm_park;
Server_IP=192.168.1.151
Port=7000
Retry_milisec=30000
DebugLog=True
TimerMilliSec=5000

step-2 ye humara EntryBarrier.py wala code hai
import socket
import datetime
import time
import mysql.connector
import threading

CONFIG_FILE = "config.txt"
LOG_FILE = "Exit_connection.txt"

def read_config():
    config = {}
    with open(CONFIG_FILE, 'r') as file:
        for line in file:
            line = line.strip()
            if "=" in line:
                key, value = line.split("=", 1)
                config[key] = value
    return config

def parse_db_config(db_path):
    db_config = {}
    items = db_path.split(";")
    for item in items:
        if "=" in item:
            key, value = item.split("=")
            db_config[key] = value
    return db_config

def log_message(message, debug_mode=True):
    if not debug_mode:
        return

    with open(LOG_FILE, 'a') as log:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log.write(f"{timestamp}: {message}\n")

def send_initial_message(client_socket):
    try:
        client_socket.sendall(INITIAL_MESSAGE.encode())
        log_message(f"Sent initial message: {INITIAL_MESSAGE}")
    except Exception as e:
        log_message(f"Failed to send initial message: {e}")

def check_exit_boom(client_socket, db_conn, timer_millisec):
    try:
        cursor = db_conn.cursor()
        while True:
            cursor.execute("SELECT exitboom FROM boomsig1")
            result = cursor.fetchone()

            if result:
                exit_boom_status = result[0]
                if exit_boom_status == 'Y':
                    log_message("Exit boom is open")
                    send_initial_message(client_socket)
                    time.sleep(3)
                    
                    # Update the exitboom status back to 'N' after the message is sent
                    cursor.execute("UPDATE boomsig1 SET exitboom = 'N'")
                    db_conn.commit()
                    log_message("Exit boom status reset to 'N' after 3 seconds")

            time.sleep(timer_millisec / 1000)  # Sleep for the timer duration
    except mysql.connector.Error as err:
        log_message(f"Database error: {err}")
    finally:
        cursor.close()

def main():
    config = read_config()

    SERVER_IP = config['Server_IP']
    SERVER_PORT = int(config['Port'])
    DB_PATH = config['DbPath']
    RETRY_MILLISECONDS = int(config['Retry_milisec'])
    TIMER_MILLISECONDS = int(config['TimerMilliSec'])
    DEBUG_LOG = config['DebugLog'] == 'True'
    
    db_config = parse_db_config(DB_PATH)

    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        client_socket.connect((SERVER_IP, SERVER_PORT))
        log_message(f"Connected to {SERVER_IP}:{SERVER_PORT}", DEBUG_LOG)
        
        db_conn = mysql.connector.connect(**db_config)
        log_message("Database connection established in advance.", DEBUG_LOG)
        
        thread = threading.Thread(target=check_exit_boom, args=(client_socket, db_conn, TIMER_MILLISECONDS))
        thread.daemon = True
        thread.start()
        
        while True:
            data = client_socket.recv(1024)
            if data:
                decoded_data = data.decode('utf-8')
                if "|HLT%" in decoded_data:
                    log_message(f"Received health packet: {decoded_data}", DEBUG_LOG)

    except ConnectionRefusedError:
        log_message(f"Connection to {SERVER_IP}:{SERVER_PORT} was refused.", DEBUG_LOG)
    except TimeoutError:
        log_message("Connection timed out. Check IP and port.", DEBUG_LOG)
    except Exception as e:
        log_message(f"An error occurred: {e}", DEBUG_LOG)
    finally:
        client_socket.close()
        db_conn.close()

if __name__ == "__main__":
    main()


this is my arduino code
#include <SPI.h>
#include <Ethernet.h>

// Network configuration
byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress server(192, 168, 1, 100);  // IP address of the Python server
int port = 12345;  // Port on which the server is listening

EthernetClient client;

// Relay pin
const int relayPin = 7;
const int healthCheckInterval = 3000; // 3 seconds

unsigned long lastHealthCheckTime = 0;

void setup() {
  // Initialize the relay pin as an output
  pinMode(relayPin, OUTPUT);
  digitalWrite(relayPin, LOW);  // Ensure relay is off initially

  // Start the Ethernet connection
  Ethernet.begin(mac);
  Serial.begin(9600);

  delay(1000);

  // Attempt to connect to the server
  if (client.connect(server, port)) {
    Serial.println("Connected to server");
  } else {
    Serial.println("Connection failed");
  }
}

void loop() {
  unsigned long currentMillis = millis();

  // Send health check message every 3 seconds
  if (client.connected() && (currentMillis - lastHealthCheckTime >= healthCheckInterval)) {
    client.println("HLT");
    lastHealthCheckTime = currentMillis;
  }

  // Check if there's data available to read
  if (client.available()) {
    String command = client.readStringUntil('\n');
    Serial.print("Received command: ");
    Serial.println(command);

    // Process the command
    if (command == "RELAY_ON") {
      digitalWrite(relayPin, HIGH);  // Turn relay on
    } else if (command == "RELAY_OFF") {
      digitalWrite(relayPin, LOW);  // Turn relay off
    }
  }

  // Check if the connection is closed
  if (!client.connected()) {
    Serial.println("Disconnected from server");
    client.stop();
    while (true) {
      delay(1);  // Do nothing here, just wait
    }
  }
}
