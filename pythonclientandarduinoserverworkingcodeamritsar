#arduino code as a server
#include <SPI.h>
#include <Ethernet.h>

#define relayPin 9

byte mac[] = {0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED};
IPAddress ip(192, 168, 1, 151);

EthernetServer server(7000);
EthernetClient client;

String clientData = "";

boolean IsClientConnected = false;

unsigned long currentMillis, previousMillis, reconnectMillis;
const unsigned long healthPacketInterval = 3000; // 3 seconds
const unsigned long reconnectInterval = 5000;   // 5 seconds

void setup() {
  Ethernet.begin(mac, ip);
  server.begin();
  Serial.begin(9600);

  while (!Serial) {
    ; // wait for the serial port to connect, needed for native USB port only
  }

  Serial.print("Machine Gate IP: ");
  Serial.println(Ethernet.localIP());

  pinMode(relayPin, OUTPUT);
  digitalWrite(relayPin, HIGH);

  // Enable the watchdog timer to reset the Arduino upon power interruption

  IsClientConnected = false;

  currentMillis = 0;
  previousMillis = 0;
  reconnectMillis = 0;
}

void loop() {

  if (!IsClientConnected) {
    if (!client.connected()) {
      client.stop(); // Ensure client is disconnected
    }
    
    EthernetClient newClient = server.available();
    if (newClient) {
      client = newClient;
      IsClientConnected = true;
      client.flush();
      Serial.println("Client Connected");
      client.println("Connected to Arduino");
    }
  }

if (IsClientConnected) 
{
    if (client.available() > 0) 
    {
      char thisChar = client.read();
      if (thisChar == '|') 
      {
        clientData = "";
      } 
      else if (thisChar == '%') 
      {
        Serial.println(clientData);
        if (clientData.equals("OPENEX")) 
        {
          Serial.println("Barrier is opening");
          digitalWrite(relayPin, LOW);
          delay(500);
          digitalWrite(relayPin, HIGH);
          delay(500);
        }
      } else {
        clientData += thisChar;
      }
    }
    
    // Check and send the health packet every 3 seconds
    currentMillis = millis();
    if (currentMillis - previousMillis >= healthPacketInterval) {
      previousMillis = currentMillis;
      client.println("|HLT%");
    }
    
    // Check if the client is still connected, if not, attempt reconnection
    if (!client.connected()) {
      Serial.println("Client Disconnected");
      IsClientConnected = false;
      reconnectMillis = millis();
    }

    // Reconnect if the reconnect interval has passed and the Ethernet link is down
    if (!IsClientConnected && (millis() - reconnectMillis >= reconnectInterval) && (Ethernet.linkStatus() == LinkOFF)) {
      Serial.println("Attempting to reconnect...");
      delay(100); // Wait for reset to occur
      server.begin(); // Restart the server
    }
  }
}

#python working code which will work as a client and check the database exitbarrier and detect Y and if Y will be detected then send the command to arduino OPENEN and arduino will receive this command and trigger the relay
import socket
import datetime
import time
import mysql.connector
import threading

SERVER_IP = '192.168.1.157'
SERVER_PORT = 7000
INITIAL_MESSAGE = "|ENTRY%"
LOG_FILE = "exit_connection_log.txt"

# MySQL database configuration
db_config = {'host': '192.168.40.100', 'user': 'root', 'password': '', 'database': 'paytm_park'}

def log_message(message):
    with open(LOG_FILE, 'a') as log:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log.write(f"{timestamp}: {message}\n")

def send_initial_message(client_socket):
    try:
        client_socket.sendall(INITIAL_MESSAGE.encode())
        log_message(f"Sent initial message: {INITIAL_MESSAGE}")
        
    except Exception as e:
        log_message(f"Failed to send initial message: {e}")

def check_exit_boom(client_socket):
    while True:
        try:
            conn = mysql.connector.connect(**db_config)
            cursor = conn.cursor()

            query = "SELECT exitboom FROM boomsig1"
            cursor.execute(query)

            result = cursor.fetchone()
            if result:
                exit_boom_status = result[0]
                if exit_boom_status == 'Y':
                    log_message("Exit boom is open")
                    send_initial_message(client_socket)
                    time.sleep(3)
                    cursor.execute("UPDATE boomsig1 SET exitboom = 'N'")
                    conn.commit()
                    log_message("Exit boom status reset to 'N' after 3 seconds")

            cursor.close()
            conn.close()

        except mysql.connector.Error as err:
            log_message(f"Error: {err}")
        
        time.sleep(1)  # Adjust the sleep duration as needed to control the check frequency

def main():
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        client_socket.connect((SERVER_IP, SERVER_PORT))
        log_message(f"Connected to {SERVER_IP}:{SERVER_PORT}")

        # Start the exit boom check in a separate thread
        thread = threading.Thread(target=check_exit_boom, args=(client_socket,))
        thread.daemon = True
        thread.start()

        while True:
            data = client_socket.recv(1024)
            if data:
                decoded_data = data.decode('utf-8')
                if "|HLT%" in decoded_data:
                    log_message(f"Received health packet: {decoded_data}")

    except ConnectionRefusedError:
        log_message(f"Connection to {SERVER_IP}:{SERVER_PORT} was refused.")
    except TimeoutError:
        log_message("Connection timed out. Check IP and port.")
    except Exception as e:
        log_message(f"An error occurred: {e}")

    finally:
        client_socket.close()

if __name__ == "__main__":
    main()
